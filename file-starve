#!/usr/bin/env python3

from argparse import ArgumentParser
from ctypes import CDLL
from os import _exit, sysconf, sysconf_names
from signal import SIGHUP, SIGINT, SIGQUIT, SIGTERM, signal
from time import monotonic


def signal_handler(signum, frame):
    """
    """
    print('\ngot signal', signum)
    _exit(1)


def mlockall():
    """
    """
    MCL_CURRENT = 1
    MCL_ONFAULT = 4

    libc = CDLL(None, use_errno=True)
    result = libc.mlockall(MCL_CURRENT | MCL_ONFAULT)

    if result != 0:
        result = libc.mlockall(MCL_CURRENT)
        if result != 0:
            print('W: cannot lock current process memory')
        else:
            print('process memory locked with MCL_CURRENT')
    else:
        print('process memory locked with MCL_CURRENT | MCL_ONFAULT')


def check_meminfo():
    """
    return KiB
    """
    fd[MEMINFO].seek(0)
    m_list = fd[MEMINFO].read().decode().split(' kB\n')
    mem_free = int(m_list[mem_free_index].split(':')[1])
    active_file = int(m_list[active_file_index].split(':')[1])
    inactive_file = int(m_list[inactive_file_index].split(':')[1])
    return mem_free, active_file + inactive_file


def check_vmstat():
    """
    return MiB
    """
    fd[VMSTAT].seek(0)
    lines = fd[VMSTAT].read().decode().split('\n')

    pgpgin = int(lines[pgpgin_index].split(' ')[1]) / K
    pgpgout = int(lines[pgpgout_index].split(' ')[1]) / K

    pswpin = int(lines[pswpin_index].split(' ')[1]) * SC_PAGESIZE / M
    pswpout = int(lines[pswpout_index].split(' ')[1]) * SC_PAGESIZE / M

    return (pgpgin, pgpgout, pswpin, pswpout)


def check_psi():
    """
    return microseconds
    """
    fd[PSI_IO].seek(0)
    fd[PSI_MEMORY].seek(0)

    some_i, full_i, _ = fd[PSI_IO].read().decode().split('\n')
    some_m, full_m, _ = fd[PSI_MEMORY].read().decode().split('\n')

    total_some_i = int(some_i.partition('total=')[2])
    total_full_i = int(full_i.partition('total=')[2])

    total_some_m = int(some_m.partition('total=')[2])
    total_full_m = int(full_m.partition('total=')[2])

    return (total_some_i, total_full_i, total_some_m, total_full_m)


def check_diskstats():
    """
    """
    fd[DISKSTATS].seek(0)

    dev_lines = fd[DISKSTATS].read().decode().split('\n')

    dev_ok = False
    for dev_line in dev_lines:
        if DEV_SEPARATOR in dev_line:
            _, _, line_rpart = dev_line.rpartition(DEV_SEPARATOR)
            dev_ok = True

    if not dev_ok:
        print('device not found')
        print('check /proc/diskstats to find available devices')
        exit(1)

    (r_ios, _, r_sectors, r_ticks, w_ios, _, w_sectors, w_ticks, _, active
     ) = line_rpart.split()[:10]

    r_ios = int(r_ios)
    r_mib = int(r_sectors) * SECTOR / M
    r_wait = int(r_ticks) / T

    w_ios = int(w_ios)
    w_mib = int(w_sectors) * SECTOR / M
    w_wait = int(w_ticks) / T

    active = int(active) / T

    return (r_ios, r_mib, r_wait, w_ios, w_mib, w_wait, active)


def restrict_file_lists():
    """
    """
    print('trying to reach the target...')

    storage = []

    t_start = monotonic()

    while True:
        mem_free, mem_file = check_meminfo()

        if mem_file > f_target:
            storage.append(bytearray(CHUNK))
        else:
            start_time = monotonic()

            pgpgin0, pgpgout0, pswpin0, pswpout0 = check_vmstat()

            if PSI_OK:
                (total_some_i0, total_full_i0, total_some_m0, total_full_m0
                 ) = check_psi()

            if DEV_OK:
                (r_ios0, r_mib0, r_wait0, w_ios0, w_mib0, w_wait0, active0
                 ) = check_diskstats()

            dt = monotonic() - t_start
            print('target reached in {}s'.format(round(dt, 1)))
            print('  file: {}M, free: {}M, passed: 0.0s'.format(
                round(mem_file / K, 1),
                round(mem_free / K, 1),
            ))

            break

    mem_free_min = mem_free_max = mem_free
    mem_file_min = mem_file_max = mem_file

    mem_file_sum = mem_free_sum = count = 0

    t_old = start_time

    while True:
        dt = monotonic() - start_time

        if dt < timeout or count == 0:
            mem_free, mem_file = check_meminfo()

            t_new = monotonic()
            if t_new - t_old >= interval:
                t_old = monotonic()

                print('  file: {}M, free: {}M, passed: {}s'.format(
                    round(mem_file / K, 1),
                    round(mem_free / K, 1),
                    round(dt, 1)
                ))

            if mem_free < mem_free_min:
                mem_free_min = mem_free

            if mem_free > mem_free_max:
                mem_free_max = mem_free

            if mem_file < mem_file_min:
                mem_file_min = mem_file

            if mem_file > mem_file_max:
                mem_file_max = mem_file

            mem_file_sum += mem_file
            mem_free_sum += mem_free

            count += 1

            if mem_file > f_target:
                storage.append(bytearray(CHUNK))
            else:
                if mem_free < mem_free_min * free_scale_factor:
                    try:
                        storage.pop()
                    except IndexError:
                        continue
        else:
            pgpgin1, pgpgout1, pswpin1, pswpout1 = check_vmstat()
            pgpgin = pgpgin1 - pgpgin0
            pgpgout = pgpgout1 - pgpgout0
            pswpin = pswpin1 - pswpin0
            pswpout = pswpout1 - pswpout0

            if PSI_OK:
                (total_some_i1, total_full_i1, total_some_m1, total_full_m1
                 ) = check_psi()
                total_some_i_sec = (total_some_i1 - total_some_i0) / m
                total_full_i_sec = (total_full_i1 - total_full_i0) / m
                total_some_m_sec = (total_some_m1 - total_some_m0) / m
                total_full_m_sec = (total_full_m1 - total_full_m0) / m

            if DEV_OK:
                (r_ios1, r_mib1, r_wait1, w_ios1, w_mib1, w_wait1, active1
                 ) = check_diskstats()
                r_ios = r_ios1 - r_ios0
                r_mib = r_mib1 - r_mib0
                r_wait = r_wait1 - r_wait0
                w_ios = w_ios1 - w_ios0
                w_mib = w_mib1 - w_mib0
                w_wait = w_wait1 - w_wait0
                active = active1 - active0

            print('  file: {}M, free: {}M, passed: {}s'.format(
                round(mem_file / K, 1),
                round(mem_free / K, 1),
                round(dt, 1)
            ))

            print('kept starved during {}s'.format(
                round(dt, 1)))

            mem_file_avg = mem_file_sum / count
            mem_free_avg = mem_free_sum / count

            print(
                'file lists and free memory sizes after reaching the target:')

            print('  file: min={}M, max={}M, average={}M'.format(
                round(mem_file_min / K, 1),
                round(mem_file_max / K, 1),
                round(mem_file_avg / K, 1)
            ))

            print('  free: min={}M, max={}M, average={}M'.format(
                round(mem_free_min / K, 1),
                round(mem_free_max / K, 1),
                round(mem_free_avg / K, 1)
            ))

            print('vmstat I/O metrics for the last {}s:\n'
                  '  pgpgin:  {}M, {}M/s\n'
                  '  pgpgout: {}M, {}M/s\n'
                  '  pswpin:  {}M, {}M/s\n'
                  '  pswpout: {}M, {}M/s'.format(
                      round(dt, 1),
                      round(pgpgin, 1), round(pgpgin / dt, 1),
                      round(pgpgout, 1), round(pgpgout / dt, 1),
                      round(pswpin, 1), round(pswpin / dt, 1),
                      round(pswpout, 1), round(pswpout / dt, 1)
                  ))

            if PSI_OK:
                print('PSI metrics for the last {}s:\n'
                      '  some io:     {}s, {}%\n'
                      '  full io:     {}s, {}%\n'
                      '  some memory: {}s, {}%\n'
                      '  full memory: {}s, {}%'.format(
                          round(dt, 1),
                          round(total_some_i_sec, 1),
                          round(total_some_i_sec / dt * 100, 1),
                          round(total_full_i_sec, 1),
                          round(total_full_i_sec / dt * 100, 1),
                          round(total_some_m_sec, 1),
                          round(total_some_m_sec / dt * 100, 1),
                          round(total_full_m_sec, 1),
                          round(total_full_m_sec / dt * 100, 1)
                      ))

            if DEV_OK:
                print('I/O statistics for {} device in the last {}s:\n'
                      '  util: {}s, {}%\n'
                      '  read: {}M, {}M/s\n'
                      '  read: {} requests processed, {} rp/s\n'
                      '  read: await {}s, {}%\n'
                      '  write: {}M, {}M/s\n'
                      '  write: {} requests processed, {} rp/s\n'
                      '  write: await {}s, {}%'.format(
                          dev,
                          round(dt, 1),
                          round(active, 1),
                          round(active / dt * 100, 1),
                          round(r_mib, 1),
                          round(r_mib / dt, 1),
                          r_ios,
                          round(r_ios / dt, 1),
                          round(r_wait, 1),
                          round(r_wait / dt * 100, 1),
                          round(w_mib, 1),
                          round(w_mib / dt, 1),
                          w_ios,
                          round(w_ios / dt, 1),
                          round(w_wait, 1),
                          round(w_wait / dt * 100, 1)
                      ))

            _exit(0)


parser = ArgumentParser()

parser.add_argument(
    '-t',
    '--target',
    help='target size of file LRU lists in MiB',
    default=20.0,
    type=float
)

parser.add_argument(
    '-T',
    '--timeout',
    help='timeout in seconds after reaching the target',
    default=60.0,
    type=float
)

parser.add_argument(
    '-s',
    '--scale',
    help='MemFree scale factor',
    default=2.0,
    type=float
)

parser.add_argument(
    '-c',
    '--chunk',
    help='chunk size in KiB',
    default=64,
    type=int
)

parser.add_argument(
    '-i',
    '--interval',
    help='output interval in seconds',
    default=10.0,
    type=float
)

parser.add_argument(
    '-d',
    '--dev',
    help='device name to track I/O stats',
    default='',
    type=str
)


args = parser.parse_args()

target = args.target
timeout = args.timeout
free_scale_factor = args.scale
chunk_size_kbytes = args.chunk
interval = args.interval
dev = args.dev

if target < 0:
    print('error: invalid target value (must be >= 0)')
    exit(1)

if timeout < 0:
    print('error: invalid timeout value (must be >= 0)')
    exit(1)

if free_scale_factor < 1:
    print('error: invalid scale factor value (must be >= 1)')
    exit(1)

if chunk_size_kbytes < 1:
    print('error: invalid chunk size value (must be >= 1)')
    exit(1)

if interval < 0:
    print('error: invalid interval value (must be >= 0)')
    exit(1)


print('starting file-starve')


K = 1024
M = K * K
m = 1000000


SC_PAGESIZE = sysconf(sysconf_names['SC_PAGESIZE'])


# in bytes
CHUNK = K * chunk_size_kbytes

# MiB -> KiB
f_target = K * target

MEMINFO = '/proc/meminfo'

VMSTAT = '/proc/vmstat'

PSI_MEMORY = '/proc/pressure/memory'

PSI_IO = '/proc/pressure/io'


fd = {}

fd[MEMINFO] = open(MEMINFO, 'rb', buffering=0)

meminfo_list = fd[MEMINFO].read().decode().split('\n')

meminfo_list_names = []

for line in meminfo_list:
    meminfo_list_names.append(line.split(':')[0])

mem_free_index = meminfo_list_names.index('MemFree')
active_file_index = meminfo_list_names.index('Active(file)')
inactive_file_index = meminfo_list_names.index('Inactive(file)')


fd[VMSTAT] = open(VMSTAT, 'rb', buffering=0)

lines = fd[VMSTAT].read().decode().split('\n')

for n, line in enumerate(lines):

    if line.startswith('pgpgin '):
        pgpgin_index = n

    if line.startswith('pgpgout '):
        pgpgout_index = n

    if line.startswith('pswpin '):
        pswpin_index = n

    if line.startswith('pswpout '):
        pswpout_index = n
        break


PSI_OK = True

try:
    fd[PSI_IO] = open(PSI_IO, 'rb', buffering=0)
    fd[PSI_MEMORY] = open(PSI_MEMORY, 'rb', buffering=0)
    fd[PSI_IO].read(1)
except Exception:
    PSI_OK = False
    print('W: PSI mertics are not available')


if dev == '':
    DEV_OK = False
    print('W: device name to track I/O stats is not set')
else:
    DEV_OK = True
    print('device name to track I/O stats:', dev)

if dev.isdigit():
    print('W: invalid device name: {}'.format(dev))
    print('check /proc/diskstats to find available devices')
    exit(1)

if DEV_OK:
    DEV_SEPARATOR = ' ' + dev + ' '
    T = 1000
    SECTOR = 512
    DISKSTATS = '/proc/diskstats'

if DEV_OK:
    try:
        fd[DISKSTATS] = open(DISKSTATS, 'rb', buffering=0)
    except Exception as e:
        DEV_OK = False
        print(e)

if DEV_OK:
    try:
        fd[DISKSTATS].read()
    except Exception as e:
        DEV_OK = False
        print(e)

if DEV_OK:
    check_diskstats()


sig_list = [SIGTERM, SIGINT, SIGQUIT, SIGHUP]

for i in sig_list:
    signal(i, signal_handler)


with open('/proc/self/oom_score_adj', 'w') as f:
    f.write('1000\n')


mlockall()

print('  target file LRU lists size: {}M'.format(target))
print('  keep starved (timeout):     {}s'.format(timeout))
print('  MemFree scale factor:       {}'.format(free_scale_factor))
print('  chunk size:                 {}K'.format(chunk_size_kbytes))

restrict_file_lists()
