#!/usr/bin/env python3

from argparse import ArgumentParser
from os import getpid, kill
from signal import SIGHUP, SIGINT, SIGQUIT, SIGTERM, SIGUSR1, signal
from sys import exit
from time import monotonic


def check_meminfo():
    """
    """
    fd[None].seek(0)
    m_list = fd[None].read().decode().split(' kB\n')
    mem_free = int(m_list[mem_free_index].split(':')[1])
    active_file = int(m_list[active_file_index].split(':')[1])
    inactive_file = int(m_list[inactive_file_index].split(':')[1])
    return mem_free, active_file + inactive_file


def keep_starved():
    """
    """
    start_time = monotonic()

    while True:
        t = monotonic() - start_time

        if t >= timeout:
            kill(self_pid, SIGUSR1)
        else:
            mem_free, mem_file = check_meminfo()

            if mem_free < free_dict[None]:
                free_dict[None] = mem_free

            if mem_file > f_target:
                ex_list.append(bytearray(CHUNK))
            else:
                if mem_free < free_dict[None] * free_scale_factor:
                    try:
                        ex_list.pop()
                    except IndexError:
                        continue


def starve():
    """
    """
    while True:
        mem_free, mem_file = check_meminfo()

        if None not in free_dict or mem_free < free_dict[None]:
            free_dict[None] = mem_free

        if mem_file > f_target:
            ex_list.append(bytearray(CHUNK))
        else:
            keep_starved()


def signal_handler(signum, frame):
    """
    """
    def signal_handler_inner(signum, frame):
        pass

    for i in sig_list:
        signal(i, signal_handler_inner)

    print('\nGot signal', signum)
    exit()


parser = ArgumentParser()


parser.add_argument(
    '-t',
    '--target',
    help='target size of file cache in MiB',
    default=10,
    type=float
)


parser.add_argument(
    '-T',
    '--timeout',
    help='timeout in seconds after reaching the target',
    default=60.0,
    type=float
)


parser.add_argument(
    '-s',
    '--scale',
    help='MemFree scale factor',
    default=2,
    type=float
)


parser.add_argument(
    '-c',
    '--chunk',
    help='chunk size in KiB',
    default=64,
    type=int
)


args = parser.parse_args()


target = args.target
timeout = args.timeout
free_scale_factor = args.scale
chunk_size_kbytes = args.chunk


if target < 0:
    print('error: invalid target value (must be >= 0)')
    exit(1)

if timeout < 0:
    print('error: invalid timeout value (must be >= 0)')
    exit(1)

if free_scale_factor < 1:
    print('error: invalid scale factor value (must be >= 1)')
    exit(1)

if chunk_size_kbytes < 1:
    print('error: invalid chunk size value (must be >= 1)')
    exit(1)


MEMINFO = '/proc/meminfo'

with open(MEMINFO) as f:
    m_list = f.readlines()

mem_list_names = []
for s in m_list:
    mem_list_names.append(s.split(':')[0])

mem_free_index = mem_list_names.index('MemFree')
active_file_index = mem_list_names.index('Active(file)')
inactive_file_index = mem_list_names.index('Inactive(file)')

ex_list = []

K = 1024

# in bytes
CHUNK = K * chunk_size_kbytes

# MiB -> KiB
f_target = K * target

fd = dict()

fd[None] = open(MEMINFO, 'rb', buffering=0)

sig_list = [SIGTERM, SIGINT, SIGQUIT, SIGHUP]

for i in sig_list:
    signal(i, signal_handler)

self_pid = getpid()

with open('/proc/self/oom_score_adj', 'w') as f:
    f.write('1000\n')

free_dict = dict()

print('Starting file-starve')
print('  target file cache size:             {} MiB'.format(target))
print('  timeout after reaching the target:  {} sec'.format(timeout))
print('  MemFree scale factor:               {}'.format(free_scale_factor))
print('  chunk size:                         {} KiB'.format(chunk_size_kbytes))


starve()
